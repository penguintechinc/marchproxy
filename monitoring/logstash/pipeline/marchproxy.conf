# MarchProxy Logstash Pipeline Configuration
# Processes logs from MarchProxy components

input {
  # Receive logs from Promtail/Loki
  http {
    port => 5044
    codec => json
  }

  # Receive UDP syslog from MarchProxy components
  udp {
    port => 5514
    codec => json
  }

  # Receive logs from Filebeat (if used)
  beats {
    port => 5045
  }

  # Direct file input for development
  file {
    path => "/var/log/marchproxy/*.log"
    start_position => "beginning"
    codec => json
  }
}

filter {
  # Parse MarchProxy Manager logs
  if [service] == "marchproxy-manager" {
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} %{GREEDYDATA:log_message}"
      }
    }

    # Parse authentication events
    if [log_message] =~ /authentication/ {
      mutate {
        add_tag => ["authentication"]
        add_field => { "event_type" => "auth" }
      }

      # Extract user and IP from auth events
      grok {
        match => {
          "log_message" => "User %{WORD:username} authentication %{WORD:auth_result} from %{IP:client_ip}"
        }
        tag_on_failure => ["_grokparsefailure_auth"]
      }
    }

    # Parse API requests
    if [log_message] =~ /API request/ {
      mutate {
        add_tag => ["api"]
        add_field => { "event_type" => "api" }
      }

      grok {
        match => {
          "log_message" => "API request %{WORD:http_method} %{URIPATH:api_path} from %{IP:client_ip} - %{INT:response_code}"
        }
        tag_on_failure => ["_grokparsefailure_api"]
      }
    }
  }

  # Parse MarchProxy Proxy logs
  if [service] == "marchproxy-proxy" {
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:component} %{GREEDYDATA:log_message}"
      }
    }

    # Parse connection events (netflow-style)
    if [log_message] =~ /connection/ {
      mutate {
        add_tag => ["netflow", "connection"]
        add_field => { "event_type" => "netflow" }
      }

      grok {
        match => {
          "log_message" => "Connection from %{IP:src_ip}:%{INT:src_port} to %{IP:dst_ip}:%{INT:dst_port} protocol %{WORD:protocol} %{WORD:action}"
        }
        tag_on_failure => ["_grokparsefailure_netflow"]
      }
    }

    # Parse proxy performance metrics
    if [log_message] =~ /performance/ {
      mutate {
        add_tag => ["performance"]
        add_field => { "event_type" => "performance" }
      }

      grok {
        match => {
          "log_message" => "Request processed in %{NUMBER:response_time}ms for %{IP:client_ip}"
        }
        tag_on_failure => ["_grokparsefailure_performance"]
      }
    }

    # Parse eBPF events
    if [log_message] =~ /ebpf/ {
      mutate {
        add_tag => ["ebpf", "acceleration"]
        add_field => { "event_type" => "ebpf" }
      }
    }

    # Parse XDP events
    if [log_message] =~ /xdp/ {
      mutate {
        add_tag => ["xdp", "acceleration"]
        add_field => { "event_type" => "xdp" }
      }
    }
  }

  # Parse PostgreSQL logs
  if [service] == "postgres" {
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{WORD:timezone} \[%{INT:pid}\] %{LOGLEVEL:level}:  %{GREEDYDATA:log_message}"
      }
    }

    mutate {
      add_tag => ["database"]
      add_field => { "event_type" => "database" }
    }
  }

  # Parse Redis logs
  if [service] == "redis" {
    grok {
      match => {
        "message" => "%{INT:pid}:%{CHAR:role} %{TIMESTAMP_ISO8601:timestamp} %{CHAR:level} %{GREEDYDATA:log_message}"
      }
    }

    mutate {
      add_tag => ["cache"]
      add_field => { "event_type" => "cache" }
    }
  }

  # Common fields for all logs
  mutate {
    add_field => { "[@metadata][index_prefix]" => "marchproxy" }
  }

  # Convert timestamp
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }

  # Add GeoIP information for external IPs
  if [client_ip] and [client_ip] !~ /^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[01])\.)/ {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # Convert numeric fields
  if [response_time] {
    mutate {
      convert => { "response_time" => "float" }
    }
  }

  if [response_code] {
    mutate {
      convert => { "response_code" => "integer" }
    }
  }

  if [src_port] {
    mutate {
      convert => { "src_port" => "integer" }
    }
  }

  if [dst_port] {
    mutate {
      convert => { "dst_port" => "integer" }
    }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => [ "message", "host" ]
  }
}

output {
  # Send to Elasticsearch with daily indices
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][index_prefix]}-%{+YYYY.MM.dd}"
    template_name => "marchproxy"
    template => "/usr/share/logstash/templates/marchproxy-template.json"
    template_overwrite => true
  }

  # Debug output (disabled by default)
  # stdout {
  #   codec => rubydebug
  # }
}