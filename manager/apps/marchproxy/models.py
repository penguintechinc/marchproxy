"""
MarchProxy Database Models

Comprehensive database schema for MarchProxy management system.
Supports both Community and Enterprise editions with appropriate
feature flagging and licensing constraints.
"""

import os
from datetime import datetime, timedelta
from pydal import DAL, Field
from pydal.validators import *

# Import from app initialization
from . import db

# Define database tables
def define_tables():
    """Define all database tables for MarchProxy"""
    
    # Users table - handles both local and external authentication
    db.define_table(
        'auth_user',
        Field('username', 'string', length=255, unique=True, notnull=True),
        Field('email', 'string', length=255, unique=True, notnull=True),
        Field('password_hash', 'password', length=512),  # For local auth
        Field('first_name', 'string', length=255),
        Field('last_name', 'string', length=255),
        Field('is_admin', 'boolean', default=False),
        Field('is_active', 'boolean', default=True),
        
        # 2FA/TOTP support
        Field('totp_secret', 'string', length=32),  # Base32 encoded secret
        Field('totp_enabled', 'boolean', default=False),
        Field('backup_codes', 'text'),  # JSON array of backup codes
        
        # External authentication support (Enterprise)
        Field('auth_provider', 'string', length=50, default='local'),  # local, saml, oauth2
        Field('external_id', 'string', length=255),  # ID from external system
        Field('external_data', 'json'),  # Additional data from external provider
        
        # Metadata
        Field('created_at', 'datetime', default=datetime.utcnow),
        Field('updated_at', 'datetime', default=datetime.utcnow, update=datetime.utcnow),
        Field('last_login', 'datetime'),
        Field('login_count', 'integer', default=0),
        
        # Validation
        format='%(username)s (%(email)s)'
    )
    
    # Clusters table (Enterprise feature, single default cluster for Community)
    db.define_table(
        'clusters',
        Field('name', 'string', length=255, notnull=True),
        Field('description', 'text'),
        Field('is_default', 'boolean', default=False),  # Default cluster for Community
        Field('is_active', 'boolean', default=True),
        
        # API key for proxy authentication (generated by py4web)
        Field('api_key', 'string', length=64, unique=True, notnull=True),
        Field('api_key_created_at', 'datetime', default=datetime.utcnow),
        Field('api_key_rotated_at', 'datetime'),
        
        # Syslog configuration per cluster
        Field('syslog_endpoint', 'string', length=255),  # host:port format
        Field('log_auth', 'boolean', default=True),      # Log authentication events
        Field('log_netflow', 'boolean', default=True),   # Log connection/netflow data
        Field('log_debug', 'boolean', default=False),    # Debug logging
        
        # License enforcement
        Field('max_proxies', 'integer', default=3),  # Community: 3, Enterprise: from license
        Field('proxy_count', 'integer', default=0),  # Current proxy count
        
        # Metadata
        Field('created_by', 'reference auth_user'),
        Field('created_at', 'datetime', default=datetime.utcnow),
        Field('updated_at', 'datetime', default=datetime.utcnow, update=datetime.utcnow),
        
        # Validation
        format='%(name)s'
    )
    
    # Services table - represents services that can be accessed
    db.define_table(
        'services',
        Field('name', 'string', length=255, notnull=True),
        Field('ip_fqdn', 'string', length=255, notnull=True),  # IP or FQDN
        Field('collection', 'string', length=255),  # Service grouping/collection
        Field('cluster_id', 'reference clusters', notnull=True),
        Field('is_active', 'boolean', default=True),
        
        # Authentication configuration (mutually exclusive)
        Field('auth_type', 'string', length=20, default='none',  # none, base64, jwt
              requires=IS_IN_SET(['none', 'base64', 'jwt'])),
        
        # Base64 token authentication
        Field('token_base64', 'string', length=512),
        
        # JWT authentication
        Field('jwt_secret', 'string', length=512),  # Secret for JWT signing/verification
        Field('jwt_expiry', 'integer', default=3600),  # JWT expiry in seconds
        Field('jwt_last_rotation', 'datetime'),
        Field('jwt_rotation_enabled', 'boolean', default=False),
        
        # Service metadata
        Field('description', 'text'),
        Field('service_owner', 'reference auth_user'),
        Field('tags', 'list:string'),  # Service tags for organization
        
        # Metadata
        Field('created_by', 'reference auth_user'),
        Field('created_at', 'datetime', default=datetime.utcnow),
        Field('updated_at', 'datetime', default=datetime.utcnow, update=datetime.utcnow),
        
        # Validation
        format='%(name)s (%(ip_fqdn)s)'
    )
    
    # Mappings table - defines source to destination access rules
    db.define_table(
        'mappings',
        Field('name', 'string', length=255, notnull=True),
        Field('description', 'text'),
        Field('cluster_id', 'reference clusters', notnull=True),
        Field('is_active', 'boolean', default=True),
        
        # Source and destination services (JSON arrays of service IDs)
        Field('source_services', 'json', notnull=True),  # List of source service IDs
        Field('dest_services', 'json', notnull=True),    # List of destination service IDs
        
        # Protocol and port configuration
        Field('protocols', 'json', default=['tcp']),  # tcp, udp, icmp, http, https, websocket
        Field('ports', 'json'),  # Port configuration: {"single": 80}, {"range": [80,90]}, {"list": [80,443,8080]}
        
        # Authentication requirements
        Field('auth_required', 'boolean', default=False),
        Field('auth_type', 'string', length=20, default='inherit',  # inherit, base64, jwt, none
              requires=IS_IN_SET(['inherit', 'base64', 'jwt', 'none'])),
        
        # Additional configuration
        Field('priority', 'integer', default=1000),  # Rule priority (lower = higher priority)
        Field('rate_limit', 'integer'),  # Requests per second limit
        Field('timeout', 'integer', default=30),  # Connection timeout in seconds
        
        # Justification and approval
        Field('justification', 'text'),  # Business justification for the mapping
        Field('approval_status', 'string', length=20, default='pending',
              requires=IS_IN_SET(['pending', 'approved', 'rejected', 'expired'])),
        Field('approved_by', 'reference auth_user'),
        Field('approved_at', 'datetime'),
        Field('expires_at', 'datetime'),  # Optional expiry for temporary access
        
        # Metadata
        Field('created_by', 'reference auth_user'),
        Field('created_at', 'datetime', default=datetime.utcnow),
        Field('updated_at', 'datetime', default=datetime.utcnow, update=datetime.utcnow),
        
        # Validation
        format='%(name)s'
    )
    
    # User-Service assignments (many-to-many for service ownership)
    db.define_table(
        'user_service_assignments',
        Field('user_id', 'reference auth_user', notnull=True),
        Field('service_id', 'reference services', notnull=True),
        Field('role', 'string', length=20, default='owner',
              requires=IS_IN_SET(['owner', 'viewer', 'editor'])),
        Field('assigned_by', 'reference auth_user'),
        Field('assigned_at', 'datetime', default=datetime.utcnow),
        
        # Composite index for uniqueness
        migrate=True
    )
    
    # User-Cluster assignments (Enterprise feature)
    db.define_table(
        'user_cluster_assignments',
        Field('user_id', 'reference auth_user', notnull=True),
        Field('cluster_id', 'reference clusters', notnull=True),
        Field('role', 'string', length=20, default='viewer',
              requires=IS_IN_SET(['admin', 'manager', 'viewer'])),
        Field('assigned_by', 'reference auth_user'),
        Field('assigned_at', 'datetime', default=datetime.utcnow),
        
        # Composite index for uniqueness
        migrate=True
    )
    
    # TLS Certificates management
    db.define_table(
        'certificates',
        Field('name', 'string', length=255, notnull=True),
        Field('description', 'text'),
        Field('cluster_id', 'reference clusters'),  # Cluster-specific or global
        
        # Certificate data
        Field('cert_data', 'text', notnull=True),  # PEM encoded certificate
        Field('key_data', 'text', notnull=True),   # PEM encoded private key
        Field('ca_data', 'text'),  # Optional CA chain
        
        # Certificate source and automation
        Field('source_type', 'string', length=20, default='manual',
              requires=IS_IN_SET(['manual', 'infisical', 'vault', 'acme'])),
        Field('source_config', 'json'),  # Source-specific configuration
        Field('auto_renew', 'boolean', default=False),
        Field('renewal_threshold_days', 'integer', default=30),
        
        # Certificate metadata
        Field('subject', 'string', length=255),
        Field('issuer', 'string', length=255),
        Field('serial_number', 'string', length=255),
        Field('fingerprint_sha256', 'string', length=64),
        Field('not_before', 'datetime'),
        Field('not_after', 'datetime'),  # Certificate expiry
        Field('san_domains', 'json'),  # Subject Alternative Names
        
        # Status
        Field('is_active', 'boolean', default=True),
        Field('last_renewal', 'datetime'),
        Field('next_renewal', 'datetime'),
        
        # Metadata
        Field('created_by', 'reference auth_user'),
        Field('created_at', 'datetime', default=datetime.utcnow),
        Field('updated_at', 'datetime', default=datetime.utcnow, update=datetime.utcnow),
        
        # Validation
        format='%(name)s'
    )
    
    # Proxy Servers registration and management
    db.define_table(
        'proxy_servers',
        Field('name', 'string', length=255, notnull=True),
        Field('hostname', 'string', length=255, notnull=True),
        Field('cluster_id', 'reference clusters', notnull=True),
        
        # Registration and status
        Field('status', 'string', length=20, default='pending',
              requires=IS_IN_SET(['pending', 'active', 'inactive', 'error'])),
        Field('registration_key', 'string', length=64),  # Used during registration
        Field('last_seen', 'datetime'),
        Field('last_config_fetch', 'datetime'),
        Field('config_version', 'string', length=64),  # SHA256 of last config
        
        # License validation
        Field('license_validated', 'boolean', default=False),
        Field('license_last_check', 'datetime'),
        Field('license_error', 'text'),
        
        # Proxy information
        Field('proxy_type', 'string', length=20, default='egress',
              requires=IS_IN_SET(['egress', 'ingress'])),
        Field('version', 'string', length=50),
        Field('go_version', 'string', length=50),
        Field('os_arch', 'string', length=50),
        Field('capabilities', 'json'),  # Supported features (eBPF, DPDK, etc.)
        
        # Performance metrics (latest)
        Field('cpu_usage', 'double'),
        Field('memory_usage', 'double'),
        Field('connection_count', 'integer', default=0),
        Field('bytes_transferred', 'bigint', default=0),
        
        # Metadata
        Field('registered_at', 'datetime', default=datetime.utcnow),
        Field('updated_at', 'datetime', default=datetime.utcnow, update=datetime.utcnow),
        
        # Validation
        format='%(name)s (%(hostname)s)'
    )

    # Ingress Routes for reverse proxy routing rules
    db.define_table(
        'ingress_routes',
        Field('name', 'string', length=255, notnull=True),
        Field('description', 'text'),
        Field('cluster_id', 'reference clusters', notnull=True),

        # Routing rules
        Field('host_pattern', 'string', length=255),  # Host-based routing (*.example.com)
        Field('path_pattern', 'string', length=255),  # Path-based routing (/api/*)
        Field('priority', 'integer', default=100),     # Lower numbers = higher priority

        # Backend services
        Field('backend_services', 'json', notnull=True),  # Array of service IDs
        Field('load_balancer_algorithm', 'string', length=20, default='round_robin',
              requires=IS_IN_SET(['round_robin', 'least_connections', 'weighted', 'ip_hash'])),
        Field('service_weights', 'json'),  # Optional weights for weighted algorithm

        # mTLS and security
        Field('require_mtls', 'boolean', default=False),
        Field('allowed_client_cns', 'json'),  # Array of allowed client certificate CNs
        Field('tls_server_name', 'string', length=255),  # SNI server name

        # Health checking
        Field('health_check_enabled', 'boolean', default=True),
        Field('health_check_path', 'string', length=255, default='/healthz'),
        Field('health_check_interval', 'integer', default=30),  # seconds
        Field('health_check_timeout', 'integer', default=5),    # seconds
        Field('health_check_threshold', 'integer', default=3),  # consecutive failures

        # Rate limiting and DDoS protection
        Field('rate_limit_enabled', 'boolean', default=False),
        Field('rate_limit_rps', 'integer', default=1000),
        Field('ddos_protection_enabled', 'boolean', default=False),
        Field('ddos_threshold_pps', 'integer', default=10000),

        # Headers and transformations
        Field('request_headers', 'json'),   # Headers to add/modify on request
        Field('response_headers', 'json'),  # Headers to add/modify on response
        Field('strip_prefix', 'string', length=255),  # Prefix to strip from path
        Field('add_prefix', 'string', length=255),    # Prefix to add to path

        # Status and metadata
        Field('is_active', 'boolean', default=True),
        Field('created_by', 'reference auth_user'),
        Field('created_at', 'datetime', default=datetime.utcnow),
        Field('updated_at', 'datetime', default=datetime.utcnow, update=datetime.utcnow),

        # Validation
        format='%(name)s (%(host_pattern)s%(path_pattern)s)'
    )

    # License cache for Enterprise edition
    db.define_table(
        'license_cache',
        Field('license_key', 'string', length=64, unique=True, notnull=True),
        Field('product_name', 'string', length=50, default='marchproxy'),
        
        # Validation data from license server
        Field('validation_data', 'json', notnull=True),
        Field('is_valid', 'boolean', default=False),
        Field('expires_at', 'datetime'),
        Field('features', 'json'),  # Licensed features array
        
        # Proxy limits
        Field('max_proxies', 'integer', default=3),
        Field('current_proxies', 'integer', default=0),
        
        # Validation tracking
        Field('last_validated', 'datetime', default=datetime.utcnow),
        Field('validation_attempts', 'integer', default=0),
        Field('last_error', 'text'),
        
        # Grace period handling
        Field('grace_period_until', 'datetime'),
        Field('in_grace_period', 'boolean', default=False),
        
        # Metadata
        Field('created_at', 'datetime', default=datetime.utcnow),
        Field('updated_at', 'datetime', default=datetime.utcnow, update=datetime.utcnow),
        
        format='%(product_name)s (%(license_key)s)'
    )
    
    # API Keys for internal authentication (py4web native)
    db.define_table(
        'api_keys',
        Field('key_name', 'string', length=255, notnull=True),
        Field('key_hash', 'string', length=64, unique=True, notnull=True),
        Field('key_prefix', 'string', length=16),  # First few chars for identification
        Field('cluster_id', 'reference clusters'),  # Cluster-specific API keys
        Field('user_id', 'reference auth_user'),   # User-specific API keys
        
        # Permissions and scope
        Field('permissions', 'json'),  # Array of permitted actions
        Field('ip_whitelist', 'json'), # Allowed IP addresses/ranges
        
        # Status and lifecycle
        Field('is_active', 'boolean', default=True),
        Field('expires_at', 'datetime'),
        Field('last_used', 'datetime'),
        Field('usage_count', 'integer', default=0),
        
        # Metadata
        Field('created_by', 'reference auth_user'),
        Field('created_at', 'datetime', default=datetime.utcnow),
        Field('updated_at', 'datetime', default=datetime.utcnow, update=datetime.utcnow),
        
        format='%(key_name)s (%(key_prefix)s...)'
    )
    
    # Audit log for security and compliance
    db.define_table(
        'audit_log',
        Field('event_type', 'string', length=50, notnull=True),  # login, logout, create, update, delete, etc.
        Field('resource_type', 'string', length=50),  # user, service, mapping, etc.
        Field('resource_id', 'string', length=255),   # ID of affected resource
        Field('user_id', 'reference auth_user'),
        Field('cluster_id', 'reference clusters'),
        
        # Event details
        Field('event_data', 'json'),  # Full event context
        Field('ip_address', 'string', length=45),  # IPv4 or IPv6
        Field('user_agent', 'text'),
        Field('success', 'boolean', default=True),
        Field('error_message', 'text'),
        
        # Timestamp
        Field('timestamp', 'datetime', default=datetime.utcnow),
        
        # No format needed for audit log
        migrate=True
    )
    
    # Configuration cache for performance
    db.define_table(
        'config_cache',
        Field('cluster_id', 'reference clusters', notnull=True),
        Field('config_hash', 'string', length=64, notnull=True),  # SHA256 of config
        Field('config_data', 'json', notnull=True),  # Cached configuration
        Field('generated_at', 'datetime', default=datetime.utcnow),
        Field('expires_at', 'datetime'),  # Cache expiry
        
        # Performance tracking
        Field('fetch_count', 'integer', default=0),
        Field('last_fetched', 'datetime'),
        
        format='Cluster %(cluster_id)s config'
    )

# Execute table definitions
define_tables()

# Create indexes for performance
def create_indexes():
    """Create database indexes for optimal performance"""
    try:
        # User lookups
        db.executesql('CREATE INDEX IF NOT EXISTS idx_auth_user_username ON auth_user(username)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_auth_user_email ON auth_user(email)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_auth_user_external_id ON auth_user(auth_provider, external_id)')
        
        # Cluster operations
        db.executesql('CREATE INDEX IF NOT EXISTS idx_clusters_api_key ON clusters(api_key)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_clusters_active ON clusters(is_active)')
        
        # Service lookups
        db.executesql('CREATE INDEX IF NOT EXISTS idx_services_cluster ON services(cluster_id)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_services_active ON services(cluster_id, is_active)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_services_auth_type ON services(auth_type)')
        
        # Mapping operations
        db.executesql('CREATE INDEX IF NOT EXISTS idx_mappings_cluster ON mappings(cluster_id)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_mappings_active ON mappings(cluster_id, is_active)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_mappings_approval ON mappings(approval_status)')
        
        # Proxy server tracking
        db.executesql('CREATE INDEX IF NOT EXISTS idx_proxy_servers_cluster ON proxy_servers(cluster_id)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_proxy_servers_status ON proxy_servers(status)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_proxy_servers_last_seen ON proxy_servers(last_seen)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_proxy_servers_type ON proxy_servers(proxy_type)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_proxy_servers_cluster_type ON proxy_servers(cluster_id, proxy_type)')

        # Ingress routes tracking
        db.executesql('CREATE INDEX IF NOT EXISTS idx_ingress_routes_cluster ON ingress_routes(cluster_id)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_ingress_routes_active ON ingress_routes(cluster_id, is_active)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_ingress_routes_priority ON ingress_routes(priority)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_ingress_routes_host ON ingress_routes(host_pattern)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_ingress_routes_path ON ingress_routes(path_pattern)')
        
        # API key lookups
        db.executesql('CREATE INDEX IF NOT EXISTS idx_api_keys_hash ON api_keys(key_hash)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_api_keys_active ON api_keys(is_active)')
        
        # Audit log queries
        db.executesql('CREATE INDEX IF NOT EXISTS idx_audit_log_timestamp ON audit_log(timestamp)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_audit_log_user ON audit_log(user_id, timestamp)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_audit_log_event ON audit_log(event_type, timestamp)')
        
        # Certificate management
        db.executesql('CREATE INDEX IF NOT EXISTS idx_certificates_cluster ON certificates(cluster_id)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_certificates_expiry ON certificates(not_after)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_certificates_renewal ON certificates(next_renewal)')
        
        # License cache
        db.executesql('CREATE INDEX IF NOT EXISTS idx_license_cache_key ON license_cache(license_key)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_license_cache_expiry ON license_cache(expires_at)')
        
        # Config cache
        db.executesql('CREATE INDEX IF NOT EXISTS idx_config_cache_cluster ON config_cache(cluster_id)')
        db.executesql('CREATE INDEX IF NOT EXISTS idx_config_cache_hash ON config_cache(config_hash)')
        
    except Exception as e:
        # Indexes may already exist, continue silently
        pass

# Create indexes on import
create_indexes()

# Commit changes
db.commit()